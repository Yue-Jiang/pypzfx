{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pzfx","text":"<p>A Python library to read and write GraphPad Prism <code>.pzfx</code> files.</p> <p>This is a Python port of the R pzfx package.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Read <code>.pzfx</code> files into pandas DataFrames</li> <li>Write pandas DataFrames to <code>.pzfx</code> format</li> <li>List all tables in a <code>.pzfx</code> file</li> <li>Handle excluded/stricken values</li> <li>Support for subcolumns (replicates) and SDN format</li> <li>Add project notes and metadata</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from pzfx import read_pzfx, write_pzfx, pzfx_tables\n\n# List tables in a file\ntables = pzfx_tables(\"data.pzfx\")\n\n# Read a table\ndf = read_pzfx(\"data.pzfx\", table=\"My Table\")\n\n# Write a DataFrame\nwrite_pzfx(df, \"output.pzfx\")\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pzfx\n</code></pre>"},{"location":"#license","title":"License","text":"<p>MIT License</p>"},{"location":"#see-also","title":"See Also","text":"<ul> <li>R pzfx package - The original R implementation</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#reading-functions","title":"Reading Functions","text":""},{"location":"api/#pzfx.pzfx_tables","title":"<code>pzfx.pzfx_tables(path)</code>","text":"<p>List all tables in a GraphPad Prism .pzfx file.</p>"},{"location":"api/#pzfx.pzfx_tables--parameters","title":"Parameters","text":"<p>path : str     Path to the .pzfx file</p>"},{"location":"api/#pzfx.pzfx_tables--returns","title":"Returns","text":"<p>list of str     Names of all tables in the file</p>"},{"location":"api/#pzfx.pzfx_tables--examples","title":"Examples","text":"<p>tables = pzfx_tables(\"data.pzfx\") print(tables) ['Table 1', 'Table 2']</p> Source code in <code>src/pzfx/read.py</code> <pre><code>def pzfx_tables(path: str) -&gt; List[str]:\n    \"\"\"\n    List all tables in a GraphPad Prism .pzfx file.\n\n    Parameters\n    ----------\n    path : str\n        Path to the .pzfx file\n\n    Returns\n    -------\n    list of str\n        Names of all tables in the file\n\n    Examples\n    --------\n    &gt;&gt;&gt; tables = pzfx_tables(\"data.pzfx\")\n    &gt;&gt;&gt; print(tables)\n    ['Table 1', 'Table 2']\n    \"\"\"\n    tree = etree.parse(path)\n    root = tree.getroot()\n\n    # Find all Table and HugeTable elements\n    table_nodes = root.xpath(\".//*[local-name()='Table' or local-name()='HugeTable']\")\n\n    tables = []\n    for t in table_nodes:\n        # Use xpath for local-name() support\n        title_nodes = t.xpath(\".//*[local-name()='Title']\")\n        if title_nodes and title_nodes[0].text:\n            tables.append(title_nodes[0].text)\n        else:\n            tables.append(\"\")\n\n    return tables\n</code></pre>"},{"location":"api/#pzfx.read_pzfx","title":"<code>pzfx.read_pzfx(path, table=1, strike_action='exclude', date_x='character')</code>","text":"<p>Read one table from a GraphPad Prism .pzfx file.</p>"},{"location":"api/#pzfx.read_pzfx--parameters","title":"Parameters","text":"<p>path : str     Path to the .pzfx file table : int or str     Table to read. Either a string (name of table) or integer (1-based position).     Defaults to 1 (first table). strike_action : str     One of \"exclude\", \"keep\", \"star\" (or \"e\", \"k\", \"s\").     How to handle excluded/stricken values:     - \"exclude\": replace with NaN     - \"keep\": keep the value     - \"star\": append \"*\" to the value (column becomes string type) date_x : str     One of \"numeric\", \"character\", \"both\" (or \"n\", \"c\", \"b\").     How to handle Date-formatted X columns.</p>"},{"location":"api/#pzfx.read_pzfx--returns","title":"Returns","text":"<p>pd.DataFrame     The table data</p>"},{"location":"api/#pzfx.read_pzfx--examples","title":"Examples","text":"<p>df = read_pzfx(\"data.pzfx\", table=1) df = read_pzfx(\"data.pzfx\", table=\"My Table\", strike_action=\"star\")</p> Source code in <code>src/pzfx/read.py</code> <pre><code>def read_pzfx(\n    path: str,\n    table: Union[int, str] = 1,\n    strike_action: str = \"exclude\",\n    date_x: str = \"character\"\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Read one table from a GraphPad Prism .pzfx file.\n\n    Parameters\n    ----------\n    path : str\n        Path to the .pzfx file\n    table : int or str\n        Table to read. Either a string (name of table) or integer (1-based position).\n        Defaults to 1 (first table).\n    strike_action : str\n        One of \"exclude\", \"keep\", \"star\" (or \"e\", \"k\", \"s\").\n        How to handle excluded/stricken values:\n        - \"exclude\": replace with NaN\n        - \"keep\": keep the value\n        - \"star\": append \"*\" to the value (column becomes string type)\n    date_x : str\n        One of \"numeric\", \"character\", \"both\" (or \"n\", \"c\", \"b\").\n        How to handle Date-formatted X columns.\n\n    Returns\n    -------\n    pd.DataFrame\n        The table data\n\n    Examples\n    --------\n    &gt;&gt;&gt; df = read_pzfx(\"data.pzfx\", table=1)\n    &gt;&gt;&gt; df = read_pzfx(\"data.pzfx\", table=\"My Table\", strike_action=\"star\")\n    \"\"\"\n    # Validate date_x\n    date_x = date_x.lower()\n    if date_x not in (\"numeric\", \"character\", \"both\", \"n\", \"c\", \"b\"):\n        raise ValueError(\"date_x must be one of ('numeric', 'character', 'both', 'n', 'c', 'b')\")\n\n    # Get table names\n    table_names = pzfx_tables(path)\n\n    # Determine table index\n    if isinstance(table, int):\n        if table &lt; 1 or table &gt; len(table_names):\n            raise IndexError(\"Table index out of range\")\n        this_idx = table - 1  # Convert to 0-based\n    else:\n        table = str(table)\n        if table not in table_names:\n            raise ValueError(f\"Can't find {table} in prism file\")\n        indices = [i for i, name in enumerate(table_names) if name == table]\n        if len(indices) &gt; 1:\n            warnings.warn(f\"Multiple tables named {table}, returning the first one only\")\n        this_idx = indices[0]\n\n    # Parse XML\n    tree = etree.parse(path)\n    root = tree.getroot()\n\n    # Find all tables\n    table_nodes = root.xpath(\".//*[local-name()='Table' or local-name()='HugeTable']\")\n    this_table = table_nodes[this_idx]\n\n    # Check for Title\n    title_elem = this_table.find(\"Title\")\n    if title_elem is None:\n        raise ValueError(\"Can't work with this pzfx file, is it later than v6.0?\")\n\n    # Get format attributes\n    x_format = this_table.get(\"XFormat\", \"\")\n    y_format = this_table.get(\"YFormat\", \"\")\n\n    # Check if XAdvancedColumn exists (for date handling)\n    has_x_advanced = this_table.find(\"XAdvancedColumn\") is not None\n\n    # First pass: collect all columns to determine max length\n    col_dfs = []\n    col_info = []  # Store (elem, tag, kwargs) for second pass if needed\n\n    for elem in this_table:\n        tag = etree.QName(elem).localname if isinstance(elem.tag, str) else elem.tag\n\n        if tag == \"XColumn\":\n            # Read normally unless it's date and we want character only\n            if x_format == \"date\" and (date_x in (\"numeric\", \"n\", \"both\", \"b\") or not has_x_advanced):\n                col_df = _read_col(elem, strike_action=strike_action, col_name=\"X\", format_=\"\")\n                if date_x in (\"both\", \"b\") and not col_df.empty:\n                    col_df.columns = [f\"{c}_1\" for c in col_df.columns]\n                col_dfs.append(col_df)\n            elif x_format == \"date\":\n                continue  # Skip XColumn for date when we only want character\n            else:\n                col_df = _read_col(elem, strike_action=strike_action, col_name=\"X\", format_=x_format)\n                col_dfs.append(col_df)\n\n        elif tag == \"XAdvancedColumn\":\n            # Only read if it's date and we want character or both\n            if x_format == \"date\" and date_x in (\"character\", \"c\", \"both\", \"b\"):\n                col_df = _read_col(elem, strike_action=strike_action, col_name=\"X\", format_=\"\")\n                if date_x in (\"both\", \"b\") and not col_df.empty:\n                    col_df.columns = [f\"{c}_2\" for c in col_df.columns]\n                col_dfs.append(col_df)\n\n        elif tag == \"RowTitlesColumn\":\n            col_df = _read_col(elem, strike_action=strike_action, col_name=\"ROWTITLE\", format_=\"\")\n            # Only include ROWTITLE if it has actual data (not all empty/NaN)\n            if not col_df.empty:\n                col_dfs.append(col_df)\n\n        elif tag == \"YColumn\":\n            col_df = _read_col(elem, strike_action=strike_action, format_=y_format)\n            col_dfs.append(col_df)\n\n    # Filter out truly empty dataframes (no columns at all)\n    col_dfs = [df for df in col_dfs if len(df.columns) &gt; 0]\n\n    if not col_dfs:\n        return pd.DataFrame()\n\n    # Find max length from non-empty columns\n    max_len = max((len(df) for df in col_dfs if not df.empty), default=0)\n\n    # Pad all DataFrames to same length and concatenate\n    padded_dfs = []\n    for df in col_dfs:\n        if df.empty and max_len &gt; 0:\n            # Empty column - fill with NaN\n            df = pd.DataFrame({col: [np.nan] * max_len for col in df.columns})\n        elif len(df) &lt; max_len:\n            padding = pd.DataFrame(\n                {col: [np.nan] * (max_len - len(df)) for col in df.columns}\n            )\n            df = pd.concat([df, padding], ignore_index=True)\n        padded_dfs.append(df)\n\n    result = pd.concat(padded_dfs, axis=1)\n    return result\n</code></pre>"},{"location":"api/#writing-functions","title":"Writing Functions","text":""},{"location":"api/#pzfx.write_pzfx","title":"<code>pzfx.write_pzfx(x, path, row_names=True, x_col=None, x_err=None, n_digits=2, notes=None, subcolumns=1, subcolumn_suffix='')</code>","text":"<p>Write one or more tables to a GraphPad Prism .pzfx file.</p>"},{"location":"api/#pzfx.write_pzfx--parameters","title":"Parameters","text":"<p>x : pd.DataFrame or dict of pd.DataFrame     Data frame or named dict of data frames to include as Prism tables. path : str     Path to output file. row_names : bool or list of bool     Include row names (index) as row titles? Default: True. x_col : int, str, or list thereof, optional     Column index (1-based) or name(s) for X column. 0 or None for none. x_err : int, str, or list thereof, optional     Column index (1-based) or name(s) for X error. 0 or None for none. n_digits : int or list of int     Number of decimal places to display for numeric data. Default: 2. notes : pd.DataFrame or dict of pd.DataFrame, optional     Notes table(s) with columns 'Name' and 'Value'. Default: None (empty notes). subcolumns : int, str, or list thereof     Number of subcolumns for Y data, or \"SDN\" for mean/SD/N format. Default: 1. subcolumn_suffix : str or list of str     Regex or string identifying grouped subcolumns (e.g., \"_[0-9]+$\" to group     A_1, A_2 as column A). Default: \"\" (no grouping).</p>"},{"location":"api/#pzfx.write_pzfx--examples","title":"Examples","text":"<p>df = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]}) write_pzfx(df, \"output.pzfx\")</p> Source code in <code>src/pzfx/write.py</code> <pre><code>def write_pzfx(\n    x: Union[pd.DataFrame, Dict[str, pd.DataFrame]],\n    path: str,\n    row_names: Union[bool, List[bool]] = True,\n    x_col: Union[int, str, List[Union[int, str]], None] = None,\n    x_err: Union[int, str, List[Union[int, str]], None] = None,\n    n_digits: Union[int, List[int]] = 2,\n    notes: Union[pd.DataFrame, Dict[str, pd.DataFrame], None] = None,\n    subcolumns: Union[int, str, List[Union[int, str]]] = 1,\n    subcolumn_suffix: Union[str, List[str]] = \"\"\n) -&gt; None:\n    \"\"\"\n    Write one or more tables to a GraphPad Prism .pzfx file.\n\n    Parameters\n    ----------\n    x : pd.DataFrame or dict of pd.DataFrame\n        Data frame or named dict of data frames to include as Prism tables.\n    path : str\n        Path to output file.\n    row_names : bool or list of bool\n        Include row names (index) as row titles? Default: True.\n    x_col : int, str, or list thereof, optional\n        Column index (1-based) or name(s) for X column. 0 or None for none.\n    x_err : int, str, or list thereof, optional\n        Column index (1-based) or name(s) for X error. 0 or None for none.\n    n_digits : int or list of int\n        Number of decimal places to display for numeric data. Default: 2.\n    notes : pd.DataFrame or dict of pd.DataFrame, optional\n        Notes table(s) with columns 'Name' and 'Value'. Default: None (empty notes).\n    subcolumns : int, str, or list thereof\n        Number of subcolumns for Y data, or \"SDN\" for mean/SD/N format. Default: 1.\n    subcolumn_suffix : str or list of str\n        Regex or string identifying grouped subcolumns (e.g., \"_[0-9]+$\" to group\n        A_1, A_2 as column A). Default: \"\" (no grouping).\n\n    Examples\n    --------\n    &gt;&gt;&gt; df = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})\n    &gt;&gt;&gt; write_pzfx(df, \"output.pzfx\")\n\n    &gt;&gt;&gt; # Multiple tables\n    &gt;&gt;&gt; tables = {'Table1': df1, 'Table2': df2}\n    &gt;&gt;&gt; write_pzfx(tables, \"output.pzfx\")\n    \"\"\"\n    # Helper functions\n    def utc_iso8601() -&gt; str:\n        \"\"\"Return current UTC time in ISO 8601 format.\"\"\"\n        return datetime.now(timezone.utc).strftime(\"%Y-%m-%dT%H:%M:%S+00:00\")\n\n    def require_length(arg: Any, n: int, name: str) -&gt; list:\n        \"\"\"Ensure argument has length 1 or n, returning a list of length n.\"\"\"\n        if not isinstance(arg, list):\n            arg = [arg]\n        if len(arg) == 1:\n            arg = arg * n\n        if len(arg) != n:\n            raise ValueError(f\"Argument '{name}' must have length 1 or {n}\")\n        return arg\n\n    def coerce_to_list_of_dfs(obj: Any, prefix: str) -&gt; Optional[Dict[str, pd.DataFrame]]:\n        \"\"\"Convert input to a dict of DataFrames.\"\"\"\n        if obj is None:\n            return None\n        if isinstance(obj, pd.DataFrame):\n            return {f\"{prefix} 1\": obj}\n        if isinstance(obj, dict):\n            # Check all values are DataFrames\n            bad = [k for k, v in obj.items() if not isinstance(v, pd.DataFrame)]\n            if bad:\n                raise TypeError(f\"These {prefix} elements are not DataFrames: {', '.join(bad)}\")\n            # Ensure names\n            if not obj:\n                return None\n            return obj\n        raise TypeError(f\"Cannot process {prefix} of type {type(obj).__name__}\")\n\n    def normalise_col_arg(arg: list, lst: Dict[str, pd.DataFrame], label: str) -&gt; List[int]:\n        \"\"\"Normalize column argument to list of integer indices (1-based, 0 means none).\"\"\"\n        arg = require_length(arg, len(lst), label)\n        result = []\n        for i, (name, df) in enumerate(lst.items()):\n            a = arg[i]\n            if a is None or (isinstance(a, float) and np.isnan(a)):\n                result.append(0)\n            elif isinstance(a, str):\n                if a == \"\":\n                    result.append(0)\n                elif a in df.columns:\n                    result.append(list(df.columns).index(a) + 1)  # 1-based\n                else:\n                    warnings.warn(f\"Column '{a}' not in table '{name}'; ignored as {label}\")\n                    result.append(0)\n            else:\n                result.append(int(a))\n        return result\n\n    def subcol_helper(values: pd.Series) -&gt; List[etree._Element]:\n        \"\"\"Create list of 'd' elements for a subcolumn.\"\"\"\n        elements = []\n        for v in values:\n            d_elem = etree.Element(\"d\")\n            if pd.isna(v):\n                # Empty element for NA\n                pass\n            else:\n                v_str = str(v)\n                if v_str.endswith(\"*\"):\n                    # Excluded value\n                    d_elem.set(\"Excluded\", \"1\")\n                    d_elem.text = v_str[:-1]  # Remove the *\n                else:\n                    d_elem.text = v_str\n            elements.append(d_elem)\n        return elements\n\n    def build_xcol_structure(\n        df: pd.DataFrame, x_idx: int, x_err_idx: int, n_dig: int\n    ) -&gt; Optional[etree._Element]:\n        \"\"\"Build XColumn element.\"\"\"\n        if x_idx == 0:\n            return None\n\n        xcol = etree.Element(\"XColumn\")\n        xcol.set(\"Width\", \"89\" if x_err_idx == 0 else \"120\")\n        xcol.set(\"Decimals\", str(n_dig))\n        xcol.set(\"Subcolumns\", \"1\" if x_err_idx == 0 else \"2\")\n\n        # Title\n        title = etree.SubElement(xcol, \"Title\")\n        title.text = df.columns[x_idx - 1]  # Convert to 0-based\n\n        # Main subcolumn\n        subcol = etree.SubElement(xcol, \"Subcolumn\")\n        for d_elem in subcol_helper(df.iloc[:, x_idx - 1]):\n            subcol.append(d_elem)\n\n        # Error subcolumn if present\n        if x_err_idx != 0:\n            subcol_err = etree.SubElement(xcol, \"Subcolumn\")\n            for d_elem in subcol_helper(df.iloc[:, x_err_idx - 1]):\n                subcol_err.append(d_elem)\n\n        return xcol\n\n    def generate_subcolumns(\n        df: pd.DataFrame, expected_count: int, suffix: str, n_dig: int\n    ) -&gt; List[etree._Element]:\n        \"\"\"Generate YColumn elements with subcolumns.\"\"\"\n        col_names = list(df.columns)\n        if not col_names:\n            col_names = [f\"V{i+1}\" for i in range(len(df.columns))]\n\n        # Group columns by removing suffix\n        if suffix:\n            grouping_factor = [re.sub(suffix, \"\", c) for c in col_names]\n        else:\n            grouping_factor = col_names\n\n        # Group columns\n        groups = {}\n        group_order = []\n        for i, (col, group) in enumerate(zip(col_names, grouping_factor)):\n            if group not in groups:\n                groups[group] = []\n                group_order.append(group)\n            groups[group].append(col)\n\n        y_columns = []\n        for group in group_order:\n            group_cols = groups[group]\n            count_found = len(group_cols)\n\n            if count_found &gt; expected_count:\n                raise ValueError(\n                    f\"Group '{group}' has {count_found} columns, but {expected_count} were expected.\"\n                )\n\n            ycol = etree.Element(\"YColumn\")\n            ycol.set(\"Width\", str(89 * expected_count))\n            ycol.set(\"Decimals\", str(n_dig))\n            ycol.set(\"Subcolumns\", str(expected_count))\n\n            # Title\n            title = etree.SubElement(ycol, \"Title\")\n            title.text = group\n\n            # Add subcolumns for existing columns\n            for col in group_cols:\n                subcol = etree.SubElement(ycol, \"Subcolumn\")\n                for d_elem in subcol_helper(df[col]):\n                    subcol.append(d_elem)\n\n            # Pad with empty subcolumns if needed\n            for _ in range(expected_count - count_found):\n                subcol = etree.SubElement(ycol, \"Subcolumn\")\n                for _ in range(len(df)):\n                    d_elem = etree.Element(\"d\")\n                    subcol.append(d_elem)\n\n            y_columns.append(ycol)\n\n        return y_columns\n\n    def build_table(\n        df: pd.DataFrame,\n        table_name: str,\n        table_idx: int,\n        row_name: bool,\n        xi: int,\n        xe: int,\n        n_dig: int,\n        subc: Union[int, str],\n        suffix: str\n    ) -&gt; etree._Element:\n        \"\"\"Build a Table element.\"\"\"\n        y_format = \"replicates\"\n        table_type = \"OneWay\"\n        x_format = \"none\"\n\n        if subc == \"SDN\":\n            y_format = \"SDN\"\n            subc = 3\n        else:\n            subc = int(subc)\n\n        # Build XColumn\n        xcol = build_xcol_structure(df, xi, xe, n_dig)\n        if xcol is not None:\n            x_format = \"numbers\" if xe == 0 else \"error\"\n            table_type = \"XY\"\n\n        # Get Y columns (exclude X and X_err columns)\n        exclude_cols = set()\n        if xi &gt; 0:\n            exclude_cols.add(xi - 1)  # Convert to 0-based\n        if xe &gt; 0:\n            exclude_cols.add(xe - 1)\n        y_col_indices = [i for i in range(len(df.columns)) if i not in exclude_cols]\n        df_y = df.iloc[:, y_col_indices]\n\n        # Generate YColumns\n        ycols = generate_subcolumns(df_y, subc, suffix, n_dig)\n\n        # Build Table element\n        table = etree.Element(\"Table\")\n        table.set(\"ID\", f\"Table{table_idx}\")\n        table.set(\"XFormat\", x_format)\n        table.set(\"YFormat\", y_format)\n        table.set(\"Replicates\", str(subc))\n        table.set(\"TableType\", table_type)\n        table.set(\"EVFormat\", \"AsteriskAfterNumber\")\n\n        # Title\n        title = etree.SubElement(table, \"Title\")\n        title.text = table_name\n\n        # RowTitlesColumn\n        if row_name:\n            row_titles = etree.SubElement(table, \"RowTitlesColumn\")\n            row_titles.set(\"Width\", \"39\")\n            subcol = etree.SubElement(row_titles, \"Subcolumn\")\n            for idx_val in df_y.index:\n                d_elem = etree.Element(\"d\")\n                d_elem.text = str(idx_val)\n                subcol.append(d_elem)\n\n        # XColumn\n        if xcol is not None:\n            table.append(xcol)\n\n        # YColumns\n        for ycol in ycols:\n            table.append(ycol)\n\n        return table\n\n    def build_info(\n        df: pd.DataFrame, info_name: str, info_idx: int\n    ) -&gt; etree._Element:\n        \"\"\"Build an Info element for notes.\"\"\"\n        info = etree.Element(\"Info\")\n        info.set(\"ID\", f\"Info{info_idx}\")\n\n        # Title\n        title = etree.SubElement(info, \"Title\")\n        title.text = info_name\n\n        # Notes section\n        notes_elem = etree.SubElement(info, \"Notes\")\n        font = etree.SubElement(notes_elem, \"Font\")\n        font.set(\"Color\", \"#000000\")\n        font.set(\"Face\", \"Helvetica\")\n\n        # Get Notes rows\n        if \"Name\" in df.columns and \"Value\" in df.columns:\n            notes_rows = df[df[\"Name\"] == \"Notes\"]\n            constants = df[df[\"Name\"] != \"Notes\"]\n\n            # Add note values\n            for _, row in notes_rows.iterrows():\n                if pd.notna(row[\"Value\"]):\n                    font.text = str(row[\"Value\"])\n                    br = etree.SubElement(font, \"BR\")\n\n            # Add constants\n            for _, row in constants.iterrows():\n                const = etree.SubElement(info, \"Constant\")\n                name_elem = etree.SubElement(const, \"Name\")\n                name_elem.text = str(row[\"Name\"])\n                value_elem = etree.SubElement(const, \"Value\")\n                if pd.notna(row[\"Value\"]):\n                    value_elem.text = str(row[\"Value\"])\n\n        return info\n\n    # Main body\n\n    # Default notes\n    if notes is None:\n        notes = {\"Project Info 1\": pd.DataFrame({\"Name\": [\"Notes\"], \"Value\": [None]})}\n\n    # Coerce inputs\n    n_lst = coerce_to_list_of_dfs(notes, \"Project Info\")\n    x_lst = coerce_to_list_of_dfs(x, \"Data\")\n\n    if x_lst is None or len(x_lst) == 0:\n        raise ValueError(\"No data tables provided\")\n\n    # Warn about non-numeric columns\n    for nm, df in x_lst.items():\n        bad_cols = [c for c in df.columns if not pd.api.types.is_numeric_dtype(df[c])]\n        if bad_cols:\n            # Check for values that are neither numeric nor *-suffixed\n            problem_values = []\n            for col in bad_cols:\n                vals = df[col].dropna()\n                for v in vals:\n                    v_str = str(v)\n                    # Skip if it ends with * (exclusion marker)\n                    if v_str.endswith(\"*\"):\n                        continue\n                    # Skip if it can be converted to numeric\n                    try:\n                        float(v_str)\n                        continue\n                    except ValueError:\n                        pass\n                    # This is a problematic value\n                    problem_values.append(v_str)\n\n            problem_values = list(set(problem_values))\n\n            if problem_values:\n                # Stronger warning for non-numeric, non-exclusion values\n                sample_vals = \", \".join(problem_values[:3])\n                if len(problem_values) &gt; 3:\n                    sample_vals += \", ...\"\n                warnings.warn(\n                    f\"Table '{nm}' has non-numeric columns ({', '.join(bad_cols)}) \"\n                    f\"containing text values that cannot be converted to numbers: {sample_vals}. \"\n                    f\"These will be written as literal text in Prism, which may not be what you intended.\"\n                )\n            else:\n                # Milder warning when all values are either numeric or *-suffixed\n                warnings.warn(\n                    f\"Table '{nm}' has non-numeric columns ({', '.join(bad_cols)}) \"\n                    f\"which will be written as text. Values ending with '*' will be marked as excluded in Prism.\"\n                )\n\n    # Normalize vector arguments\n    n_tables = len(x_lst)\n    row_names_list = require_length(row_names if isinstance(row_names, list) else [row_names], n_tables, \"row_names\")\n    subcolumns_list = require_length(subcolumns if isinstance(subcolumns, list) else [subcolumns], n_tables, \"subcolumns\")\n    suffix_list = require_length(subcolumn_suffix if isinstance(subcolumn_suffix, list) else [subcolumn_suffix], n_tables, \"subcolumn_suffix\")\n    n_digits_list = require_length(n_digits if isinstance(n_digits, list) else [n_digits], n_tables, \"n_digits\")\n\n    # Normalize column arguments\n    x_col_list = normalise_col_arg(\n        x_col if isinstance(x_col, list) else [x_col] if x_col is not None else [None],\n        x_lst, \"x_col\"\n    )\n    x_err_list = normalise_col_arg(\n        x_err if isinstance(x_err, list) else [x_err] if x_err is not None else [None],\n        x_lst, \"x_err\"\n    )\n\n    # Validate column indices\n    for i, (name, df) in enumerate(x_lst.items()):\n        nc = len(df.columns)\n        if x_col_list[i] &gt; nc or x_err_list[i] &gt; nc:\n            raise IndexError(f\"Not enough columns for table {name}\")\n\n    # Build XML structure\n    root = etree.Element(\"GraphPadPrismFile\")\n    root.set(\"PrismXMLVersion\", \"5.00\")\n\n    # Created element\n    created = etree.SubElement(root, \"Created\")\n    orig_version = etree.SubElement(created, \"OriginalVersion\")\n    orig_version.set(\"CreatedByProgram\", \"GraphPad Prism\")\n    orig_version.set(\"CreatedByVersion\", \"6.0f.254\")\n    orig_version.set(\"Login\", \"\")\n    orig_version.set(\"DateTime\", utc_iso8601())\n\n    # InfoSequence\n    if n_lst:\n        info_seq = etree.SubElement(root, \"InfoSequence\")\n        for i in range(len(n_lst)):\n            ref = etree.SubElement(info_seq, \"Ref\")\n            ref.set(\"ID\", f\"Info{i}\")\n            if i == 0:\n                ref.set(\"Selected\", \"1\")\n\n        # Info elements\n        for i, (name, df) in enumerate(n_lst.items()):\n            info_elem = build_info(df, name, i)\n            root.append(info_elem)\n\n    # TableSequence\n    table_seq = etree.SubElement(root, \"TableSequence\")\n    for i in range(len(x_lst)):\n        ref = etree.SubElement(table_seq, \"Ref\")\n        ref.set(\"ID\", f\"Table{i}\")\n        if i == 0:\n            ref.set(\"Selected\", \"1\")\n\n    # Table elements\n    for i, (name, df) in enumerate(x_lst.items()):\n        table_elem = build_table(\n            df, name, i,\n            row_names_list[i],\n            x_col_list[i],\n            x_err_list[i],\n            n_digits_list[i],\n            subcolumns_list[i],\n            suffix_list[i]\n        )\n        root.append(table_elem)\n\n    # Write to file\n    tree = etree.ElementTree(root)\n    tree.write(path, encoding=\"utf-8\", xml_declaration=True, pretty_print=True)\n</code></pre>"},{"location":"api/#pzfx.write_pzfx--multiple-tables","title":"Multiple tables","text":"<p>tables = {'Table1': df1, 'Table2': df2} write_pzfx(tables, \"output.pzfx\")</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install from PyPI:</p> <pre><code>pip install pzfx\n</code></pre> <p>Or install from source:</p> <pre><code>git clone https://github.com/Yue-Jiang/pypzfx.git\ncd pypzfx\npip install -e .\n</code></pre>"},{"location":"getting-started/#reading-pzfx-files","title":"Reading .pzfx Files","text":""},{"location":"getting-started/#list-tables-in-a-file","title":"List tables in a file","text":"<pre><code>from pzfx import pzfx_tables\n\ntables = pzfx_tables(\"data.pzfx\")\nprint(tables)  # ['Table 1', 'Table 2']\n</code></pre>"},{"location":"getting-started/#read-a-table","title":"Read a table","text":"<pre><code>from pzfx import read_pzfx\n\n# Read the first table (default)\ndf = read_pzfx(\"data.pzfx\")\n\n# Read by table name\ndf = read_pzfx(\"data.pzfx\", table=\"My Table\")\n\n# Read by index (1-based)\ndf = read_pzfx(\"data.pzfx\", table=2)\n</code></pre>"},{"location":"getting-started/#handle-excluded-values","title":"Handle excluded values","text":"<p>GraphPad Prism allows you to \"strike\" or exclude values from analysis. Control how these are handled:</p> <pre><code># Replace with NaN (default)\ndf = read_pzfx(\"data.pzfx\", strike_action=\"exclude\")\n\n# Keep the original value\ndf = read_pzfx(\"data.pzfx\", strike_action=\"keep\")\n\n# Append \"*\" to mark excluded values\ndf = read_pzfx(\"data.pzfx\", strike_action=\"star\")\n</code></pre>"},{"location":"getting-started/#writing-pzfx-files","title":"Writing .pzfx Files","text":""},{"location":"getting-started/#write-a-dataframe","title":"Write a DataFrame","text":"<pre><code>import pandas as pd\nfrom pzfx import write_pzfx\n\ndf = pd.DataFrame({\n    'Control': [1.2, 2.3, 3.1],\n    'Treatment': [2.5, 3.8, 4.2]\n})\n\nwrite_pzfx(df, \"output.pzfx\")\n</code></pre>"},{"location":"getting-started/#write-multiple-tables","title":"Write multiple tables","text":"<pre><code>tables = {\n    'Experiment 1': df1,\n    'Experiment 2': df2\n}\nwrite_pzfx(tables, \"output.pzfx\")\n</code></pre>"},{"location":"getting-started/#write-xy-data","title":"Write XY data","text":"<pre><code>df = pd.DataFrame({\n    'Time': [0, 1, 2, 3],\n    'Response': [0.1, 0.5, 0.9, 0.99]\n})\n\nwrite_pzfx(df, \"xy_data.pzfx\", x_col=\"Time\")\n</code></pre>"},{"location":"getting-started/#add-project-notes","title":"Add project notes","text":"<pre><code>notes = pd.DataFrame({\n    'Name': ['Notes', 'Experiment ID', 'Researcher'],\n    'Value': ['My experiment description', 'EXP-001', 'Jane Doe']\n})\n\nwrite_pzfx(df, \"output.pzfx\", notes=notes)\n</code></pre>"},{"location":"getting-started/#write-with-subcolumns-replicates","title":"Write with subcolumns (replicates)","text":"<pre><code># Columns ending with _1, _2, _3 are grouped together\ndf = pd.DataFrame({\n    'Control_1': [1.1, 2.1],\n    'Control_2': [1.2, 2.2],\n    'Control_3': [1.3, 2.3],\n    'Treatment_1': [2.1, 3.1],\n    'Treatment_2': [2.2, 3.2],\n    'Treatment_3': [2.3, 3.3]\n})\n\nwrite_pzfx(df, \"replicates.pzfx\", subcolumns=3, subcolumn_suffix='_[0-9]+$')\n</code></pre>"},{"location":"getting-started/#write-sdn-format-mean-sd-with-n","title":"Write SDN format (Mean \u00b1 SD with N)","text":"<pre><code>df = pd.DataFrame({\n    'Control_MEAN': [1.5, 2.5],\n    'Control_SD': [0.2, 0.3],\n    'Control_N': [5, 5],\n    'Treatment_MEAN': [2.5, 3.5],\n    'Treatment_SD': [0.3, 0.4],\n    'Treatment_N': [5, 5]\n})\n\nwrite_pzfx(df, \"summary.pzfx\", subcolumns='SDN', subcolumn_suffix='_(MEAN|SD|N)$')\n</code></pre>"},{"location":"getting-started/#mark-excluded-values","title":"Mark excluded values","text":"<p>Values ending with <code>*</code> are marked as excluded in Prism:</p> <pre><code>df = pd.DataFrame({\n    'Control': ['1.2', '2.3*', '3.1'],  # 2.3 will be excluded\n    'Treatment': ['2.5', '3.8', '4.2*']  # 4.2 will be excluded\n})\n\nwrite_pzfx(df, \"with_exclusions.pzfx\")\n</code></pre>"},{"location":"examples/examples/","title":"pzfx Library Playground","text":"In\u00a0[\u00a0]: Copied! <pre># Import the library\nfrom pzfx import read_pzfx, write_pzfx, pzfx_tables\nimport pandas as pd\n</pre> # Import the library from pzfx import read_pzfx, write_pzfx, pzfx_tables import pandas as pd In\u00a0[\u00a0]: Copied! <pre># List all tables in a test file\ntables = pzfx_tables('../tests/testdata/column.pzfx')\nprint(tables)\n</pre> # List all tables in a test file tables = pzfx_tables('../tests/testdata/column.pzfx') print(tables) In\u00a0[\u00a0]: Copied! <pre># Read by table index (1-based)\ndf = read_pzfx('../tests/testdata/column.pzfx', table=1)\ndf\n</pre> # Read by table index (1-based) df = read_pzfx('../tests/testdata/column.pzfx', table=1) df In\u00a0[\u00a0]: Copied! <pre># Read by table name\ndf = read_pzfx('../tests/testdata/column.pzfx', table='Data 1')\ndf\n</pre> # Read by table name df = read_pzfx('../tests/testdata/column.pzfx', table='Data 1') df In\u00a0[\u00a0]: Copied! <pre># Read file with excluded/stricken values\ndf_exclude = read_pzfx('../tests/testdata/x_y_with_strike.pzfx', strike_action='exclude')\ndf_keep = read_pzfx('../tests/testdata/x_y_with_strike.pzfx', strike_action='keep')\ndf_star = read_pzfx('../tests/testdata/x_y_with_strike.pzfx', strike_action='star')\n\nprint(\"strike_action='exclude':\")\ndisplay(df_exclude)\nprint(\"\\nstrike_action='keep':\")\ndisplay(df_keep)\nprint(\"\\nstrike_action='star':\")\ndisplay(df_star)\n</pre> # Read file with excluded/stricken values df_exclude = read_pzfx('../tests/testdata/x_y_with_strike.pzfx', strike_action='exclude') df_keep = read_pzfx('../tests/testdata/x_y_with_strike.pzfx', strike_action='keep') df_star = read_pzfx('../tests/testdata/x_y_with_strike.pzfx', strike_action='star')  print(\"strike_action='exclude':\") display(df_exclude) print(\"\\nstrike_action='keep':\") display(df_keep) print(\"\\nstrike_action='star':\") display(df_star) In\u00a0[\u00a0]: Copied! <pre># Create a sample DataFrame\ndf = pd.DataFrame({\n    'Control': [1.2, 2.3, 3.1, 2.8],\n    'Treatment': [2.5, 3.8, 4.2, 3.9]\n})\ndf\n</pre> # Create a sample DataFrame df = pd.DataFrame({     'Control': [1.2, 2.3, 3.1, 2.8],     'Treatment': [2.5, 3.8, 4.2, 3.9] }) df In\u00a0[\u00a0]: Copied! <pre># Write to .pzfx file\nwrite_pzfx(df, 'my_data.pzfx')\nprint(\"Written to my_data.pzfx\")\n</pre> # Write to .pzfx file write_pzfx(df, 'my_data.pzfx') print(\"Written to my_data.pzfx\") In\u00a0[\u00a0]: Copied! <pre># Verify by reading it back\ndf_read = read_pzfx('my_data.pzfx')\ndf_read\n</pre> # Verify by reading it back df_read = read_pzfx('my_data.pzfx') df_read In\u00a0[\u00a0]: Copied! <pre># Create multiple DataFrames as a dict\ndata = {\n    'Experiment 1': pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]}),\n    'Experiment 2': pd.DataFrame({'X': [10, 20], 'Y': [30, 40]})\n}\n\nwrite_pzfx(data, 'multi_table.pzfx')\nprint(\"Tables:\", pzfx_tables('multi_table.pzfx'))\n</pre> # Create multiple DataFrames as a dict data = {     'Experiment 1': pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]}),     'Experiment 2': pd.DataFrame({'X': [10, 20], 'Y': [30, 40]}) }  write_pzfx(data, 'multi_table.pzfx') print(\"Tables:\", pzfx_tables('multi_table.pzfx')) In\u00a0[\u00a0]: Copied! <pre># Create XY data\ndf_xy = pd.DataFrame({\n    'Time': [0, 1, 2, 3, 4],\n    'Response': [0.1, 0.5, 0.9, 0.95, 0.99]\n})\n\n# Write with Time as X column\nwrite_pzfx(df_xy, 'xy_data.pzfx', x_col='Time')\nprint(\"Written XY data\")\n</pre> # Create XY data df_xy = pd.DataFrame({     'Time': [0, 1, 2, 3, 4],     'Response': [0.1, 0.5, 0.9, 0.95, 0.99] })  # Write with Time as X column write_pzfx(df_xy, 'xy_data.pzfx', x_col='Time') print(\"Written XY data\") In\u00a0[\u00a0]: Copied! <pre># Create notes DataFrame with Name/Value columns\n# \"Notes\" is a special name that becomes the project description\nnotes_df = pd.DataFrame({\n    'Name': ['Notes', 'Experiment ID', 'Researcher', 'Date'],\n    'Value': ['This is my experiment description.', 'EXP-2024-001', 'Jane Doe', '2024-12-01']\n})\n\ndf = pd.DataFrame({\n    'Control': [1.2, 2.3, 3.1],\n    'Treatment': [2.5, 3.8, 4.2]\n})\n\nwrite_pzfx(df, 'with_notes.pzfx', notes=notes_df)\nprint(\"Written with notes. Check 'Project Info' in Prism.\")\n</pre> # Create notes DataFrame with Name/Value columns # \"Notes\" is a special name that becomes the project description notes_df = pd.DataFrame({     'Name': ['Notes', 'Experiment ID', 'Researcher', 'Date'],     'Value': ['This is my experiment description.', 'EXP-2024-001', 'Jane Doe', '2024-12-01'] })  df = pd.DataFrame({     'Control': [1.2, 2.3, 3.1],     'Treatment': [2.5, 3.8, 4.2] })  write_pzfx(df, 'with_notes.pzfx', notes=notes_df) print(\"Written with notes. Check 'Project Info' in Prism.\") In\u00a0[\u00a0]: Copied! <pre># Example: 3 replicates per condition\n# Columns named Control_1, Control_2, Control_3 will be grouped as \"Control\"\ndf_reps = pd.DataFrame({\n    'Control_1': [1.1, 2.1, 3.1],\n    'Control_2': [1.2, 2.2, 3.2],\n    'Control_3': [1.3, 2.3, 3.3],\n    'Treatment_1': [2.1, 3.1, 4.1],\n    'Treatment_2': [2.2, 3.2, 4.2],\n    'Treatment_3': [2.3, 3.3, 4.3]\n})\n\n# subcolumns=3 means 3 replicates\n# subcolumn_suffix removes \"_1\", \"_2\", \"_3\" to group columns\nwrite_pzfx(df_reps, 'with_replicates.pzfx', subcolumns=3, subcolumn_suffix='_[0-9]+$')\nprint(\"Written with 3 replicates per group\")\n\n# Verify structure\nprint(\"\\nTables:\", pzfx_tables('with_replicates.pzfx'))\ndf_back = read_pzfx('with_replicates.pzfx')\ndf_back\n</pre> # Example: 3 replicates per condition # Columns named Control_1, Control_2, Control_3 will be grouped as \"Control\" df_reps = pd.DataFrame({     'Control_1': [1.1, 2.1, 3.1],     'Control_2': [1.2, 2.2, 3.2],     'Control_3': [1.3, 2.3, 3.3],     'Treatment_1': [2.1, 3.1, 4.1],     'Treatment_2': [2.2, 3.2, 4.2],     'Treatment_3': [2.3, 3.3, 4.3] })  # subcolumns=3 means 3 replicates # subcolumn_suffix removes \"_1\", \"_2\", \"_3\" to group columns write_pzfx(df_reps, 'with_replicates.pzfx', subcolumns=3, subcolumn_suffix='_[0-9]+$') print(\"Written with 3 replicates per group\")  # Verify structure print(\"\\nTables:\", pzfx_tables('with_replicates.pzfx')) df_back = read_pzfx('with_replicates.pzfx') df_back In\u00a0[\u00a0]: Copied! <pre># SDN format: columns for Mean, SD, and N\n# Suffix pattern groups them together\ndf_sdn = pd.DataFrame({\n    'Control_MEAN': [1.5, 2.5, 3.5],\n    'Control_SD': [0.2, 0.3, 0.4],\n    'Control_N': [5, 5, 5],\n    'Treatment_MEAN': [2.5, 3.5, 4.5],\n    'Treatment_SD': [0.3, 0.4, 0.5],\n    'Treatment_N': [5, 5, 5]\n})\n\nwrite_pzfx(df_sdn, 'sdn_format.pzfx', subcolumns='SDN', subcolumn_suffix='_(MEAN|SD|N)$')\nprint(\"Written in SDN format\")\n</pre> # SDN format: columns for Mean, SD, and N # Suffix pattern groups them together df_sdn = pd.DataFrame({     'Control_MEAN': [1.5, 2.5, 3.5],     'Control_SD': [0.2, 0.3, 0.4],     'Control_N': [5, 5, 5],     'Treatment_MEAN': [2.5, 3.5, 4.5],     'Treatment_SD': [0.3, 0.4, 0.5],     'Treatment_N': [5, 5, 5] })  write_pzfx(df_sdn, 'sdn_format.pzfx', subcolumns='SDN', subcolumn_suffix='_(MEAN|SD|N)$') print(\"Written in SDN format\") In\u00a0[\u00a0]: Copied! <pre># Values ending with * are marked as excluded in Prism\ndf_excluded = pd.DataFrame({\n    'Control': ['1.2', '2.3*', '3.1'],  # 2.3 will be excluded\n    'Treatment': ['2.5', '3.8', '4.2*']  # 4.2 will be excluded\n})\n\nwrite_pzfx(df_excluded, 'with_exclusions.pzfx')\nprint(\"Written with excluded values\")\n\n# Read back with different strike_action to see the effect\nprint(\"\\nReading back with strike_action='star':\")\nread_pzfx('with_exclusions.pzfx', strike_action='star')\n</pre> # Values ending with * are marked as excluded in Prism df_excluded = pd.DataFrame({     'Control': ['1.2', '2.3*', '3.1'],  # 2.3 will be excluded     'Treatment': ['2.5', '3.8', '4.2*']  # 4.2 will be excluded })  write_pzfx(df_excluded, 'with_exclusions.pzfx') print(\"Written with excluded values\")  # Read back with different strike_action to see the effect print(\"\\nReading back with strike_action='star':\") read_pzfx('with_exclusions.pzfx', strike_action='star')"},{"location":"examples/examples/#pzfx-library-playground","title":"pzfx Library Playground\u00b6","text":"<p>This notebook demonstrates how to use the pzfx library to read and write GraphPad Prism files.</p>"},{"location":"examples/examples/#1-list-tables-in-a-pzfx-file","title":"1. List tables in a .pzfx file\u00b6","text":""},{"location":"examples/examples/#2-read-a-table-from-a-pzfx-file","title":"2. Read a table from a .pzfx file\u00b6","text":""},{"location":"examples/examples/#3-read-with-different-strike_action-options","title":"3. Read with different strike_action options\u00b6","text":"<ul> <li><code>\"exclude\"</code> (default): Replace excluded values with NaN</li> <li><code>\"keep\"</code>: Keep original value</li> <li><code>\"star\"</code>: Append <code>*</code> to excluded values</li> </ul>"},{"location":"examples/examples/#4-write-a-dataframe-to-pzfx","title":"4. Write a DataFrame to .pzfx\u00b6","text":""},{"location":"examples/examples/#5-write-multiple-tables","title":"5. Write multiple tables\u00b6","text":""},{"location":"examples/examples/#6-write-xy-data-with-x-column","title":"6. Write XY data with X column\u00b6","text":""},{"location":"examples/examples/#7-add-project-notesmetadata","title":"7. Add project notes/metadata\u00b6","text":""},{"location":"examples/examples/#8-write-with-subcolumns-replicates","title":"8. Write with subcolumns (replicates)\u00b6","text":"<p>Use <code>subcolumns</code> to specify how many replicates per group, and <code>subcolumn_suffix</code> to group columns by a regex pattern.</p>"},{"location":"examples/examples/#9-write-sdn-format-mean-sd-with-n","title":"9. Write SDN format (Mean \u00b1 SD with N)\u00b6","text":"<p>Use <code>subcolumns=\"SDN\"</code> for pre-calculated summary statistics.</p>"},{"location":"examples/examples/#10-mark-excluded-values-with-asterisk","title":"10. Mark excluded values with asterisk\u00b6","text":"<p>When writing, values ending with <code>*</code> are marked as excluded in Prism.</p>"}]}